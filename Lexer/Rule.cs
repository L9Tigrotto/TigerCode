
namespace Lexer;

/// <summary>
/// Represents the result of a lexer rule match operation.
/// This struct encapsulates information about whether a match was found,
/// the length of the matched text, whether the end of the file has been reached,
/// and the token generated by the rule.
/// </summary>
/// <typeparam name="TToken">The type of token produced by the lexer rule.</typeparam>
public readonly struct MatchResult<TToken>
{
    /// <summary>
    /// Indicates whether a match was found by the LexerRule.Match method.
    /// </summary>
    public bool IsMatchFound { get; init; } 

    /// <summary>
    /// The length of the matched text.
    /// </summary>
    public int MatchedTextLength { get; init; } 

    /// <summary>
    /// Indicates whether the end of the file has been reached.
    /// </summary>
    public bool IsEndOfFile { get; init; } 

    /// <summary>
    /// The token generated by the rule, if a match was found.
    /// </summary>
    public TToken GeneratedToken { get; init; }

    /// <summary>
    /// Initializes a new instance of the MatchResult struct.
    /// </summary>
    /// <param name="isMatchFound">True if a match was found; otherwise, false.</param>
    /// <param name="matchedTextLength">The length of the matched text.</param>
    /// <param name="isEndOfFile">True if the end of the file has been reached; otherwise, false.</param>
    /// <param name="generatedToken">The token generated by the rule, if a match was found; otherwise, null.</param>
    public MatchResult(bool isMatchFound, int matchedTextLength, bool isEndOfFile, TToken generatedToken)
    {
        IsMatchFound = isMatchFound;
        MatchedTextLength = matchedTextLength;
        IsEndOfFile = isEndOfFile;
        GeneratedToken = generatedToken;
    }
}

/// <summary>
/// Abstract base class for lexer rules.
/// </summary>
/// <typeparam name="TToken">The type of token produced by the lexer rule.</typeparam>
public abstract class Rule<TToken>
{
    /// <summary>
    /// Gets or sets a value indicating whether the lexer should return the token if a match is found.
    /// If true, the token is returned; if false, the token is skipped and the lexer looks for the next one.
    /// </summary>
    public bool ReturnTokenOnMatch { get; protected set; }

    /// <summary>
    /// Gets or sets a collection of rules that are likely to follow the current rule.
    /// If none of these rules match, the lexer will cycle through all stored rules.
    /// </summary>
    public Rule<TToken>[] SubsequentRules { get; set; }

    /// <summary>
    /// Initializes a new instance of the LexerRule class with the specified return behavior.
    /// </summary>
    /// <param name="returnTokenOnMatch">True to return the token on match; false to skip the token.</param>
    /// <param name="subsequentRules">A collection of rules that are likely to follow the current rule.</param>
    protected Rule(bool returnTokenOnMatch, Rule<TToken>[] subsequentRules)
    {
        ReturnTokenOnMatch = returnTokenOnMatch;
        SubsequentRules = subsequentRules;
    }

    /// <summary>
    /// Initializes a new instance of the LexerRule class with the specified return behavior.
    /// </summary>
    /// <param name="returnTokenOnMatch">True to return the token on match; false to skip the token.</param>
    protected Rule(bool returnTokenOnMatch) : this(returnTokenOnMatch, subsequentRules: []) { }

    /// <summary>
    /// Attempts to match the input text and produce a token.
    /// </summary>
    /// <param name="input">The input text to match.</param>
    /// <returns>
    /// A MatchResult containing information about whether a match was found,
    /// the length of the matched text, whether the end of the file has been reached,
    /// and the generated token if a match was found.
    /// </returns>
    public abstract MatchResult<TToken> Match(ReadOnlyMemory<char> input);
}